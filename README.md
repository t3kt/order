order
=====

order is a visualization system based on structured data processing, without randomization or noise.

[output videos](https://vimeo.com/album/2736128)

see also http://t3kt.net/projects/order

![example output](http://farm4.staticflickr.com/3787/13365828224_95d9d7f556_o.jpg "Example Output")

## system structure
Order is composed of several subsystems:
* [input and control systems](#input-and-control-systems)
* [geometry systems](#geometry-systems)
* [rendering](#rendering)
* [post-processing](#post-processing)

## input and control systems
The input and control systems handle various inputs, timing, etc. The ultimate output of these systems is a set of parameter values each ranging from 0..1 (though occasionally slightly outside that range).

* input handling - routes MIDI and Leap Motion input to system parameters
* control UI - control panel UI for viewing and editing parameters
* audio I/O
* audio analysis and routing
* timing

## geometry systems
The geometry systems start with patterns of overlapping simple shapes, and go through several layers of transformation to ultimately generate a set of line segments (and a set of their endpoints), which then is passed to the renderer. The entire geometry system is 2D (it's actually 3D but all Z coordinates are always 0).
* [geometry generators](#geometry-generators)
* [initial distortion](#initial-distortion)
* [threshold](#threshold)
* [post-threshold distortion](#post-threshold-distortion)

### geometry generators
There are several alternate generators, but only one of them is active at any given time. They are all variations on the same idea. Starting with a simple shape (usually a hexagon), copies of that shape are placed at the corners of the orginal, with sizes and rotations that vary over time. This process is sometimes compounded a second time (more copies at all points of the first set of copies, etc). The result is a set of basic primitives that overlap each other it different ways over time.

All the geometry generators use an animation sequence which controls various rotations and scalings (all in 2D). Three control parameters can be used to modify the animation sequence values (making something spin faster/slower, etc).

### initial distortion
The generated geometry passes through a layer of distortion, which uses a Magnet SOP to twist the points in various ways.

### threshold
The threshold phase takes the distorted geometry and finds pairs of points that are within a certain range of distance from each other, and generates a connecting line segment for each such pair. The result of this is that when two shapes are passing over each other, as they cross, connections are drawn between pairs of points as they get within a certain distance, and then disappear one shape moves further away from the other.

The threshold phase is based on the [DistThresholdCHOP](https://github.com/t3kt/DistThresholdCHOP), which was originally created by [Vincent Houze](https://github.com/vinz9). I have since extended it to support more control over the ranges, and also to provide several different modes of operation.

### post-threshold distortion
The line segments generated by the [threshold](#threshold) phase passses through another layer of distortion which twists the line segments and pushes/pulls them in different directions.

## rendering
The threshold connector lines use a basic wireframe material with a constant color, but with opacity that increases as the connectors get shorter.

The connection points use a point sprite material with a circular gradient (basically a circle with a fuzzy edge that's slightly darker in the middle).

There is a single camera that never moves, and no lighting since there aren't any phong or other such materials.

There is a renderer that renders because it enjoys rendering. It's quite happy.

## post-processing
After the renderer produces a stream of images, that stream is fed through a series of post-processing effects.
* color adjustment
* echo
* bloom

   Bloom is basically just a blur, where it takes a slight (short-distance) blur and a heavier (longer distance) blur and adds them, combined with the original image. This produces a halo-like effect, and can slightly fill in areas between nearby lines.

* stutter
* feedback!

   The feedback effect is a loop where a frame is mixed with the previous frame and the output of that is fed back into it as the next "previous frame". When the opacity of the previous/feedback frames is low, this results in small trails behind anything that moves, which fade the further they get away from the original line. When the opacity is much higher (almost 100%), it would normally just end up eventually making everything white. To deal with this, the feedback image is processed with an edging effect, which effectively makes portions of it transparent, allowing it to mix without overwhelming the resulting image.


